#  杂项

## STL

+ copy
```cpp
template <class InputIterator, class OutputIterator>
  OutputIterator copy (InputIterator first, InputIterator last, OutputIterator result);
```
+ merge (如果相等，第一个优先)
```cpp
template <class InputIterator1, class InputIterator2,
          class OutputIterator, class Compare>
  OutputIterator merge (InputIterator1 first1, InputIterator1 last1,
                        InputIterator2 first2, InputIterator2 last2,
                        OutputIterator result, Compare comp);
```
+ for_each
```cpp
template <class InputIterator, class Function>
   Function for_each (InputIterator first, InputIterator last, Function fn);
```
+ transform
```cpp
template <class InputIterator, class OutputIterator, class UnaryOperation>
  OutputIterator transform (InputIterator first1, InputIterator last1,
                            OutputIterator result, UnaryOperation op);
```
+ numeric_limits
```cpp
template <class T> numeric_limits;
```
+ iota

```cpp
template< class ForwardIterator, class T >
void iota( ForwardIterator first, ForwardIterator last, T value );
```

## 伪随机数

```cpp
unsigned rnd() {
    static unsigned A = 1 << 16 | 3, B = 33333331, C = 2341;
    return C = A * C + B;
}
```

## 日期

```cpp
// Routines for performing computations on dates.  In these routines,
// months are exprsesed as integers from 1 to 12, days are expressed
// as integers from 1 to 31, and years are expressed as 4-digit
// integers.

string dayOfWeek[] = {"Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"};

// converts Gregorian date to integer (Julian day number)

int DateToInt (int m, int d, int y){  
  return 
    1461 * (y + 4800 + (m - 14) / 12) / 4 +
    367 * (m - 2 - (m - 14) / 12 * 12) / 12 - 
    3 * ((y + 4900 + (m - 14) / 12) / 100) / 4 + 
    d - 32075;
}

// converts integer (Julian day number) to Gregorian date: month/day/year

void IntToDate (int jd, int &m, int &d, int &y){
  int x, n, i, j;

  x = jd + 68569;
  n = 4 * x / 146097;
  x -= (146097 * n + 3) / 4;
  i = (4000 * (x + 1)) / 1461001;
  x -= 1461 * i / 4 - 31;
  j = 80 * x / 2447;
  d = x - 2447 * j / 80;
  x = j / 11;
  m = j + 2 - 12 * x;
  y = 100 * (n - 49) + i + x;
}

// converts integer (Julian day number) to day of week

string IntToDay (int jd){
  return dayOfWeek[jd % 7];
}
```

## 子集枚举

+ 枚举真子集

```cpp
for (int s = (S - 1) & S; s; s = (s - 1) & S)
```

+ 枚举大小为 k 的子集

```cpp
template<typename T>
void subset(int k, int n, T&& f) {
    int t = (1 << k) - 1;
    while (t < 1 << n) {
        f(t);
        int x = t & -t, y = t + x;
        t = ((t & ~y) / x >> 1) | y;
    }
}
```

## 权值最大上升子序列

```cpp
const LL maxn = 1E5 + 10;
const LL INF = 1E10;
struct P {
    LL k, v;
    bool operator < (const P& rhs) const {
        return k < rhs.k || (k == rhs.k && v < rhs.v);
    }
};
LL k[maxn], v[maxn], n, T;
set<P> s;

int main() {
    cin >> T;
    while (T--) {
        s.clear();
        s.insert({-INF, 0});
        cin >> n;
        FOR (i, 0, n) scanf("%lld", &k[i]);
        FOR (i, 0, n) scanf("%lld", &v[i]);
        FOR (i, 0, n) {
            auto it = s.lower_bound({k[i], INF});
            LL vv = (--it)->v + v[i];
            ++it;
            while (it != s.end() && it->v <= vv)
                it = s.erase(it);
            if (it == s.end() || it->k != k[i]) s.insert({k[i], vv});
        }
        cout << s.rbegin()->v << endl;
    }
}
```

## 数位 DP

```cpp
LL dfs(LL base, LL pos, LL len, LL s, bool limit) {
    if (pos == -1) return s ? base : 1;
    if (!limit && dp[base][pos][len][s] != -1) return dp[base][pos][len][s];
    LL ret = 0;
    LL ed = limit ? a[pos] : base - 1;
    FOR (i, 0, ed + 1) {
        tmp[pos] = i;
        if (len == pos)
            ret += dfs(base, pos - 1, len - (i == 0), s, limit && i == a[pos]);
        else if (s &&pos < (len + 1) / 2)
            ret += dfs(base, pos - 1, len, tmp[len - pos] == i, limit && i == a[pos]);
        else
            ret += dfs(base, pos - 1, len, s, limit && i == a[pos]);
    }
    if (!limit) dp[base][pos][len][s] = ret;
    return ret;
}

LL solve(LL x, LL base) {
    LL sz = 0;
    while (x) {
        a[sz++] = x % base;
        x /= base;
    }
    return dfs(base, sz - 1, sz - 1, 1, true);
}
```

## 土制 bitset

```cpp
// M 要开大至少 1 个 64
const int M = (1E4 + 200) / 64;
typedef unsigned long long ULL;
const ULL ONE = 1;

struct Bitset {
    ULL a[M];
    void go(int x) {
        int offset = x / 64; x %= 64;
        for (int i = offset, j = 0; i + 1 < M; ++i, ++j) {
            a[j] |= a[i] >> x;
            if (x) a[j] |= a[i + 1] << (64 - x); // 不能左移 64 位
        }
    }
    void init() { memset(a, 0, sizeof a); }
    void set(int x) {
        int offset = x / 64; x %= 64;
        a[offset] |= (ONE << x);
    }
    void prt() {
        FOR (i, 0, M) FOR (j, 0, 64) putchar((a[i] & (ONE << j)) ? '1' : '0');
        puts("");
    }
    int lowbit() {
        FOR (i, 0, M) if (a[i]) return i * 64 + __builtin_ctzll(a[i]);
        assert (0);
    }
    int highbit(int x) {
        // [0,x) 的最高位
        int offset = x / 64; x %= 64;
        FORD (i, offset, -1) {
            if (!a[i]) continue;
            if (i == offset) {
                FORD (j, x - 1, -1) if ((ONE << j) & a[i]) { return i * 64 + j; }
            } else return i * 64 + 63 - __builtin_clzll(a[i]);
        }
        assert (0);
    }
};
```

## 随机

+ 不要使用 `rand()`。
+ `chrono::steady_clock::now().time_since_epoch().count()` 可用于计时。
+ 64 位可以使用 `mt19937_64`。

```cpp
int main() {
    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());
    vector<int> permutation(N);

    for (int i = 0; i < N; i++)
        permutation[i] = i;
    shuffle(permutation.begin(), permutation.end(), rng);

    for (int i = 0; i < N; i++)
        permutation[i] = i;
    for (int i = 1; i < N; i++)
        swap(permutation[i], permutation[uniform_int_distribution<int>(0, i)(rng)]);
```

## 扩栈（本地使用）

```cpp
#include <sys/resource.h>
void init_stack(){
    const rlim_t kStackSize = 512 * 1024 * 1024;
    struct rlimit rl;
    int result;
    result = getrlimit(RLIMIT_STACK, &rl);
    if (result == 0) {
        if (rl.rlim_cur < kStackSize) {
            rl.rlim_cur = kStackSize;
            result = setrlimit(RLIMIT_STACK, &rl);
            if (result != 0) {
                fprintf(stderr, "setrlimit returned result = %d\n", result);
            }
        }
    }
}
```

## 心态崩了

+ `(int)v.size()`
+ `1LL << k`
+ 递归函数用全局或者 static 变量要小心
+ 预处理组合数注意上限
+ 想清楚到底是要 `multiset` 还是 `set`
+ 提交之前看一下数据范围，测一下边界
+ 数据结构注意数组大小 （2倍，4倍）
+ 字符串注意数据集
+ 如果函数中使用了默认参数的话，注意调用时的参数个数。
+ 注意要读完
+ 构造参数无法使用自己
+ 树链剖分/dfs 序，初始化或者询问不要忘记 idx, ridx
+ 排序时注意结构体的所有属性是不是考虑了
+ 不要把 while 写成 if
+ 不要把 int 开成 char
+ 清零的时候全部用 0~n+1。
+ 模意义下不要用除法
+ 哈希不要自然溢出
+ 最短路不要 SPFA，乖乖写 Dijkstra
+ 上取整以及 GCD 小心负数
+ mid 用 `l + (r - l) / 2` 可以避免溢出和负数的问题

